---
tags:
  - 技术/NET
---
## 反射的概念

元数据是用一系列表来存储的，生成程序集或模块时，编译器会创建一个类型定义表，一个字段定义表，一个方法定义表以及其他表。利用 `System.Reflection`  命名空间中包含的类型，可以写代码来反射这些元数据表。实际上命名空间中的类型为程序集或模块中包含的元数据提供了一个对象模型。

利用对象模型中的类型，可以轻松枚举定义元数据表中的所有类型，而针对每个类型都可以获得它的基类型，实现的接口以及与类型关联的标志（flag）。利用 `System.Reflection` 命名空间中的其他类型，还可解析对应元数据表来查询类型的字段、方法、属性和事件。甚至有些类允许判断引用的程序集，还有一些方法能返回一个方法的字节流。

只有极少数应用程序才需要使用反射类型。如果类库需要理解类型的定义才能提供丰富的功能，就适合使用反射。例如 FCL 的序列化机制（关联： [[内容/技术/NET/CLR/核心机制/运行时序列化/运行时序列化|运行时序列化]]）就是利用反射来判断类型定义了哪些字段。然后序列化格式器可获取这些字段的值，把他们写入字节流以便通过 Internet 传送、保存到文件或复制到剪切板。类似的，在设计期间，Microsoft Visual Studio 设计器在 Web 窗体或 Windows 窗体上放置控件时，也利用反射来决定要向开发人员显示的属性。

在运行时，当应用程序需要从特定程序集中加载特定类型以执行特定任务时，也需要使用反射。例如，应用程序要求用户提供程序集和类型名，然后应用程序可显式加载程序集，构造类型的实例，再调用类型中的定义的方法。以这种方式绑定到类型并调用方法称为晚期绑定。